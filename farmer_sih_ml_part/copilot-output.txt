What I built

- A new FastAPI service that loads and orchestrates:
  - Plant-Disease-Detection PyTorch model + CSV metadata to return disease description, prevention steps, and supplement info.
  - AgriGo’s ML models to return recommended crop (used as a yield-proxy) and fertilizer.
- OpenAPI/Swagger docs at /docs with request/response schemas.
- Optional Keras path for disease detection using AgriGo’s per-crop .h5 models (if you prefer those instead of the PyTorch model).

Where it lives

- New files:
  - unified_api/main.py — the unified API (FastAPI)
  - unified_api/requirements.txt — dependencies for this API
  - unified_api/README.md — how to run and use it
- Reused assets (without moving them):
  - Torch model + CSVs: Plant-Disease-Detection/Flask Deployed App/plant_disease_model_1_latest.pt, disease_info.csv, supplement_info.csv
  - Keras .h5 models (optional path): AgriGo/AgriGo/models/DL_models/*.h5
  - ML pickles and datasets: AgriGo/AgriGo/models/ML_models/*.pkl, AgriGo/AgriGo/dataset/*.csv

Endpoints

- POST /disease/predict
  - Purpose: detect disease from an image, return name, confidence, description, prevention, and recommended supplement.
  - Request:
    - Multipart/form-data with field file (the image).
    - Optional query parameters:
      - approach = torch (default) or keras
      - crop = required when approach=keras (one of: apple, cherry, corn, grape, peach, pepper, tomato, strawberry, patato)
  - Response (JSON):
    - disease_index: integer
    - disease_name: string
    - confidence: float (0..1)
    - description: string (torch approach)
    - prevention_steps: string (torch approach)
    - image_url: string (torch approach)
    - supplement: object with name, image, buy_link (torch approach)
  - Behavior:
    - torch approach uses the 39-class CNN from Plant-Disease-Detection and enriches with disease_info.csv and supplement_info.csv.
    - keras approach reproduces AgriGo’s per-crop Keras prediction; it returns the class name and confidence (no CSV-enriched fields).

- POST /yield-and-fertilizer
  - Purpose: predict yield proxy (best crop) and fertilizer recommendation together.
  - Request (JSON):
    - Crop recommendation inputs:
      - N, P, K, temperature, humidity, ph, rainfall (float)
    - Fertilizer inputs:
      - fert_temperature, fert_humidity, moisture (float)
      - soil_type (one of: Black, Clayey, Loamy, Red, Sandy)
      - crop_type (one of: Barley, Cotton, Ground Nuts, Maize, Millets, Oil seeds, Paddy, Pulses, Sugarcane, Tobacco, Wheat)
      - nitrogen, potassium, phosphorous (float)
  - Response (JSON):
    - recommended_crop: string
    - fertilizer: string (one of: 10-26-26, 14-35-14, 17-17-17, 20-20, 28-28, DAP, Urea)
  - Note: The repository does not include a standalone yield model. I use AgriGo’s crop recommendation as a pragmatic yield-proxy to meet your “yield prediction” page needs. If you add a true yield model later, we can plug it in without changing the contract.

- GET /metadata/fertilizer-options
  - Returns soil_types, crop_types, and fertilizer_classes for frontend dropdowns.

- GET /health
  - Health check.

How it uses your existing code/models

- Disease (default): Torch CNN (CNN.py + plant_disease_model_1_latest.pt) from Plant-Disease-Detection, and the CSVs to provide disease descriptions and supplement recommendations.
- Disease (optional): AgriGo’s per-crop .h5 Keras models (mirrors functions.py logic) with the same input preprocessing and class mappings; this path returns the class and confidence (no CSV-based extras).
- Yield proxy (crop recommendation): AgriGo’s scikit-learn model.
- Fertilizer recommendation: AgriGo’s scikit-learn model using the same numeric + categorical features.

Running it

- Install dependencies (PowerShell):

pip install -r unified_api/requirements.txt

- Start the API:

python -m uvicorn unified_api.main:app --host 0.0.0.0 --port 8000

- Open docs:
  - Swagger UI: http://localhost:8000/docs
  - OpenAPI JSON: http://localhost:8000/openapi.json

Example calls

- Disease detection (torch, default):

curl -X POST "http://localhost:8000/disease/predict" -F "file=@Plant-Disease-Detection/test_images/apple_healthy.JPG"

- Disease detection (AgriGo Keras per-crop):

curl -X POST "http://localhost:8000/disease/predict?approach=keras&crop=apple" -F "file=@AgriGo/AgriGo/uploads/apple-rust-disease_3_3497055209.jpeg"

- Yield + fertilizer:

curl -X POST "http://localhost:8000/yield-and-fertilizer" -H "Content-Type: application/json" -d '{
  "N": 90, "P": 42, "K": 43, "temperature": 21, "humidity": 82, "ph": 6.5, "rainfall": 202,
  "fert_temperature": 26, "fert_humidity": 52, "moisture": 38, "soil_type": "Sandy", "crop_type": "Maize",
  "nitrogen": 37, "potassium": 0, "phosphorous": 0
}'

Notable implementation details

- OpenAPI/Swagger: Automatically generated by FastAPI; request/response schemas are typed with Pydantic models (includes validation and examples).
- Keras dependency is optional: If you call /disease/predict?approach=keras, you’ll need TensorFlow installed (e.g., tensorflow-cpu==2.8.0 like AgriGo). If you stick to the default approach=torch, no TensorFlow is needed.
- scikit-learn pickles and Python 3.12:
  - If your current Python environment can’t unpickle the old scikit-learn models, the service will automatically retrain equivalent DecisionTree models from the CSV datasets on first import and cache them. This keeps the service running without changing your original pickles.
  - For bit-for-bit parity with the original pickles, use Python + scikit-learn 1.0.2 to load them directly.

Small extras

- Added a metadata endpoint for soil/crop/fertilizer options to help populate your frontend dropdowns easily.
- The disease endpoint supports both your Torch and Keras approaches so you can align with whichever path your UI prefers.

How your frontend can consume this

- Two pages = two calls:
  - Disease page -> POST /disease/predict (multipart with image). Default is the Torch model enriched with descriptions/supplements via CSVs.
  - Yield page -> POST /yield-and-fertilizer (JSON). Returns recommended crop and fertilizer in one shot.
- The OpenAPI at /docs shows example payloads and schema constraints. You can also generate client SDKs if you like (e.g., with openapi-generator).

Quality gates

- Build/deps: Installed successfully (FastAPI, Torch, scikit-learn, pandas, etc.) in a Python 3.12 environment; verified OpenAPI generation via import.
- Lint/typecheck: Not run as part of this session; code is typed with Pydantic models and minimal runtime validation.
- Unit tests: Not present in the repo; I validated the app loads and endpoints register by generating and inspecting the OpenAPI schema.
- Smoke test: Torch/CSV assets found; Keras path requires TensorFlow if you use it. scikit-learn pickle incompatibility is handled via retraining fallback.

Requirements coverage:
- Single API that combines both projects: Done (unified_api/main.py).
- Endpoints:
  1) Disease detection with description and treatment recommendation: Done (default Torch path returns description, steps, supplement).
  2) Yield prediction and fertilizer recommendation: Done (yield proxy via crop recommendation + fertilizer in one endpoint).
- Swagger/OpenAPI: Done (/docs, /openapi.json).
- Uses same models and data: Done (Torch model and CSVs reused; Keras models supported optionally; AgriGo ML reused or retrained from CSV to ensure runtime compatibility).
